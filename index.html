<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
      
 
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      
      <!-- Web Components polyfill is required to support Edge and Firefox < 63: -->
        <script src="./js/webcomponents-loader.js"></script>
        <!-- Resize Observer polyfill is required for non-Chrome browsers: -->
        <script src="./js/ResizeObserver.js"></script>
        <!-- Intersection Observer polyfill is required for Safari and IE11 -->
        <script src="./js/intersection-observer.js"></script>
        <!-- Fullscreen polyfill is required for using experimental AR features in Canary: -->
        <script src="./js/fullscreen.polyfill.js"></script>
        <script src="./js/model-viewer.js"></script>

<!-- Load model-viewer modules and disable viewer border -->
<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>


<!-- Load focus-visible module for improved focus visibility -->
<script src="https://unpkg.com/focus-visible@5.0.2/dist/focus-visible.js" defer></script>


<script src="https://cdn.jsdelivr.net/npm/qrcodejs/qrcode.min.js"></script>

</head>
  
    <body>



        <model-viewer id="model"
          style="width: 100%; height:82.5vh;"
          
           
          auto-rotate
          shadow-intensity="1" 
          autoplay
          exposure="1"
          environment-image="neutral"
          ar
          camera-controls 
          ar-placement=""
          min-camera-orbit='auto auto 100%'
          max-camera-orbit='auto auto 100%'
          
          src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/chair-viewar.glb"
          ios-src=""
          ondrop="loadDroppedModel(event);" 
          ondragover="dragover_handler(event);"
          >

    <!-- Style for the AR button -->


    <!-- AR button with associated image -->
    <a slot="ar-button"  id="ar-button">
        <img class="btn-ar" src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/view-in-ar.png" alt="AR button">
    </a>



          
 
<!-- Toggle Button -->
<div class="toggle-button">
    <img src="https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/set-f2.png" alt="Settings Toggle" id="toggle-button-img">
    <span class="tooltip-text">Settings</span>
</div>


  <style>
/* === 1) Original upload button styles (unchanged) === */
.upload-button {
  position: absolute;
  top: 10px;
  left: 10px; /* Adjust as needed */
  z-index: 2;
}
.upload-button img {
  width: 45px;
  height: 45px;
  cursor: pointer;
}
.upload-button input[type="file"] {
  display: none;
}
.upload-button label {
  cursor: pointer;
}
.upload-button .tooltip-text {
  visibility: hidden;
  width: 150px;
  background-color: #555;
  color: #fff;
  text-align: center;
  border-radius: 5px;
  padding: 5px 0;
  position: absolute;
  z-index: 1;
  top: 40%;
  left: 105%;
  margin-left: 10px;
  transform: translateY(-50%);
  opacity: 0;
  transition: opacity 0.3s;
}
.upload-button .tooltip-text::after {
  content: "";
  position: absolute;
  top: 50%;
  right: 100%;
  margin-top: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent #555 transparent transparent;
  transform: translateY(-50%);
}
.upload-button:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

/* Hide tooltip when menu is active */
.upload-button.active .tooltip-text {
  visibility: hidden !important;
  opacity: 0 !important;
}

/* === 2) Updated Upload Menu – transparent container, no black box === */
.upload-menu {
  display: none;             /* hidden by default */
  position: absolute;
  top: 0;                    /* align with top of upload button */
  left: 110%;                /* place to the right of the upload button */
  background: transparent;   /* no background */
  border: none;
  padding: 0;
  margin: 0;
  z-index: 10;
}

/* === 3) Updated Buttons Styling – smaller size, fully round edges === */
.upload-item-label {
  display: inline-block;
  width: 175px;            /* slightly smaller width */
  height: 45px;            /* slightly bigger height */
  line-height: 40px;       /* match height for vertical centering */
  background: black;
  border: 2px solid white;
  border-radius: 50px;     /* fully round edges */
  margin: 0;               /* adjust vertical alignment */
  color: white;
  font-weight: normal;
  font-size: 17px;
  padding: 0 16px;
  box-sizing: border-box;
  white-space: nowrap;
  cursor: pointer;
  text-align: center;
}
.upload-item-label:hover {
  background: rgba(0,0,0,0.8);
}


/* === 4) USDZ Row: Place USDZ button below GLB button, info button stays to the right === */
.usdz-row {
  display: flex;
  align-items: center;
  gap: 3px; /* space between USDZ button and info button */
  margin-top: 5px; /* small gap below GLB button */
}

/* Wrap USDZ row and info dialog in a relative container */
.usdz-container {
  position: relative;
}

/* Info button remains unchanged */
.info-button {
  width: 28px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  border-radius: 50%;
  background-color: #555;
  color: #fff;
  cursor: pointer;
  font-size: 16px;
  flex-shrink: 0;
  z-index: 3;
}

/* === 5) Info dialog: now appears below the USDZ row === */
.info-dialog {
  display: none;
  position: absolute;
  top: 100%; /* directly below the USDZ row */
  left: 0;
  width: 260px; /* match the width of the buttons */
  background: black;
  color: white;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 10px;
  box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
  font-size: 13px;
  box-sizing: border-box;
  z-index: 9999;
  margin-top: 0px;
  
}


  </style>

<!-- The main upload button container -->
<div class="upload-button" id="upload-button">
  <!-- Toggle Button (Upload icon + tooltip) -->
  <label id="upload-toggle-label">
    <img src="https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/up-f2.png" alt="Upload">
    <span class="tooltip-text">Upload model</span>
  </label>

  <!-- The upload menu – now just a container for the buttons -->
  <div class="upload-menu" id="upload-menu">
    <!-- GLB button -->
    <input type="file" accept=".glb,.gltf" id="file-upload-model" style="display:none;">
    <label for="file-upload-model" class="upload-item-label">GLB / glTF</label>

    <!-- USDZ container: contains USDZ row and info dialog -->
    <div class="usdz-container">
      <div class="usdz-row">
        <input type="file" accept=".usdz" id="file-upload-usdz" style="display:none;">
        <label for="file-upload-usdz" class="upload-item-label">USDZ (optional)</label>
        <div class="info-button" id="info-button">i</div>
      </div>
      <div class="info-dialog" id="info-dialog">
        <p>
          <strong>1.</strong> ViewAR auto-converts GLB / glTF files to USDZ for iOS,
          but <strong>animated</strong> models need a separate USDZ upload for AR playback on iOS.<br>
          <strong>2.</strong> Uploaded USDZ files are only used for AR mode on iOS. You still need to upload a GLB / glTF file for browser display.
        </p>
      </div>
    </div>
  </div>
</div>



  <script>
// Grab references
const uploadButton  = document.getElementById('upload-button');
const uploadToggle  = document.getElementById('upload-toggle-label');
const uploadMenu    = document.getElementById('upload-menu');
const infoButton    = document.getElementById('info-button');
const infoDialog    = document.getElementById('info-dialog');

// Toggle the menu when clicking the upload icon
uploadToggle.addEventListener('click', function(e) {
  if (uploadMenu.style.display === 'block') {
    uploadMenu.style.display = 'none';
    uploadButton.classList.remove('active');
  } else {
    uploadMenu.style.display = 'block';
    uploadButton.classList.add('active');
  }
  infoDialog.style.display = 'none';
  e.stopPropagation();
});



// Prevent clicks inside the menu from closing it
uploadMenu.addEventListener('click', function(e) {
  e.stopPropagation();
});

// Close menu & info dialog when clicking outside
document.addEventListener('click', function(e) {
  if (!uploadButton.contains(e.target)) {
    uploadMenu.style.display = 'none';
    infoDialog.style.display = 'none';
    uploadButton.classList.remove('active');  // Remove active class so tooltip can show
  }
});


// Info dialog: show on both hover and click
function showInfoDialog() {
  infoDialog.style.display = 'block';
}
function hideInfoDialog() {
  infoDialog.style.display = 'none';
}
infoButton.addEventListener('click', function(e) {
  if (infoDialog.style.display === 'block') {
    hideInfoDialog();
  } else {
    showInfoDialog();
  }
  e.stopPropagation();
});
infoButton.addEventListener('mouseenter', showInfoDialog);
infoButton.addEventListener('mouseleave', function() {
  setTimeout(function() {
    if (!infoDialog.matches(':hover')) {
      hideInfoDialog();
    }
  }, 100);
});
infoDialog.addEventListener('mouseenter', showInfoDialog);
infoDialog.addEventListener('mouseleave', hideInfoDialog);

// Automatically close the menu when a file is selected
document.getElementById('file-upload-model').addEventListener('change', function(e) {
  if (this.files.length > 0) {
    loadUploadedModel(e);
    uploadMenu.style.display = 'none';
  }
});
let usdzFile = null;
document.getElementById('file-upload-usdz').addEventListener('change', function(e) {
  if (this.files.length > 0) {
    usdzFile = this.files[0];
    loadUploadedUSDZModel(e);
    uploadMenu.style.display = 'none';
  }
});


  </script>


<!-- Spectrum button -->
    <div class="spectrum-button" id="spectrum-button">
       
<img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/Color_circle_(RGB).png" alt="Spectrum" id="spectrum-button-img">
           <span class="tooltip-text">Background Color</span>      
    </div>


          
 
      <div class="controls hidden">
    <label for="variant" style="color: white;">Variant:</label><br>
    <div><select id="variant"></select></div>
  </div>

<!-- Dropdown for background selection -->
<div class="dropdown-container hidden">
    <label for="background-select" style="color: white;">Background:</label><br>
    <select id="background-select">
        <option value="none">None</option>
        <option value="mg">Misty Morning</option>
        <option value="tg">Tranquil Garden</option>
        <option value="sd">Sunny Day</option>
        <option value="ob">Ocean Breeze</option>
        <option value="sm">Spring Meadow</option>
        <option value="mn">Moonlit Night</option>
        <option value="nd">Neon Dream</option> <!-- Updated Gradient -->
        <option value="dm">Desert Mirage</option> <!-- Updated Gradient -->
        <option value="ds">Deep Space</option>    <!-- New Gradient -->
        <option value="sg">Sunset Glow</option>   <!-- New Gradient -->
    </select>
</div>



<style>
#color-spectrum {
    width: 35px;
    height: 180px;
    background: linear-gradient(to bottom, 
                                red, 
                                yellow, 
                                green, 
                                cyan, 
                                blue, 
                                magenta, 
                                red);
    border-radius: 50px;
    position: absolute;
    top: 130px; 
    right: 10px;
    cursor: pointer;
    border: 2px solid black;  /* Added thin black outline */
}

.color-button {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    border: 2px solid;
    position: absolute;
    right: 10px;
    cursor: pointer;
    z-index: 2;
}

.white-button {
    background-color: white;
    border-color: black;
    top: 325px; /* Adjust to position below spectrum bar */
}

.black-button {
    background-color: black;
    border-color: lightgray;
    top: 370px; /* Position below the white button */
}

/* Add a class to prevent text selection only during color picking */
.no-select {
    -webkit-user-select: none; /* Chrome, Opera, and Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* Internet Explorer/Edge */
    user-select: none;         /* Non-prefixed version */
}      

/* Hidden class to control visibility */
.hidden {
    display: none;
}
</style>
          
<div id="color-spectrum" class="hidden"></div>

<!-- Color buttons -->
<div class="color-button white-button hidden"></div>
<div class="color-button black-button hidden"></div>

<script>
let selectedColor = '';
let selectedBackgroundKey = 'none';
const colorSpectrum = document.getElementById('color-spectrum');
const modelViewer = document.getElementById('model');
const spectrumButton = document.getElementById('spectrum-button');
const whiteButton = document.querySelector('.white-button');
const blackButton = document.querySelector('.black-button');
const backgroundSelect = document.getElementById('background-select');

colorSpectrum.addEventListener('mousedown', startPickingColor);
colorSpectrum.addEventListener('touchstart', startPickingColor, { passive: false });

function startPickingColor(event) {
    colorSpectrum.classList.add('no-select');
    pickColor(event);
    document.addEventListener('mousemove', pickColor);
    document.addEventListener('mouseup', stopPickingColor);
    document.addEventListener('touchmove', pickColor, { passive: false });
    document.addEventListener('touchend', stopPickingColor);
}

function stopPickingColor() {
    colorSpectrum.classList.remove('no-select');
    document.removeEventListener('mousemove', pickColor);
    document.removeEventListener('mouseup', stopPickingColor);
    document.removeEventListener('touchmove', pickColor);
    document.removeEventListener('touchend', stopPickingColor);
}

function pickColor(event) {
    event.preventDefault();
    const rect = colorSpectrum.getBoundingClientRect();
    const y = event.clientY || event.touches[0].clientY;
    const relativeY = y - rect.top;
    const height = rect.height;
    const percentage = relativeY / height;
    const color = getColorFromSpectrum(percentage);

    selectedColor = color;
    selectedBackgroundKey = ''; // Clear the background key to indicate a spectrum color
    applyBackground(color);
}

function getColorFromSpectrum(percentage) {
    const hue = percentage * 360;
    return `hsl(${hue}, 100%, 50%)`;
}

// Toggle the spectrum bar and buttons visibility
spectrumButton.addEventListener('click', (event) => {
    event.stopPropagation(); // Prevent the click event from propagating to the document
    toggleVisibility([colorSpectrum, whiteButton, blackButton]);
});

// Hide the spectrum bar and buttons when clicking outside of them
document.addEventListener('click', (event) => {
    if (!colorSpectrum.contains(event.target) && 
        !spectrumButton.contains(event.target) && 
        !whiteButton.contains(event.target) &&
        !blackButton.contains(event.target)) {
        hideElements([colorSpectrum, whiteButton, blackButton]);
    }
});

// Prevent clicks inside the spectrum bar and buttons from closing them
[colorSpectrum, whiteButton, blackButton].forEach(element => {
    element.addEventListener('click', (event) => {
        event.stopPropagation();
    });

    element.addEventListener('touchstart', (event) => {
        event.stopPropagation();
    });
});

// Add event listener to the white button
whiteButton.addEventListener('click', () => {
    selectedBackgroundKey = 'none';
    selectedColor = '';
    applyBackground('none');
});

// Add event listener to the black button
blackButton.addEventListener('click', () => {
    selectedBackgroundKey = 'black';
    selectedColor = '#000000'; // Hex color value for black
    applyBackground('black');
});

// Add event listener to the custom background select element
backgroundSelect.addEventListener('change', () => {
    selectedBackgroundKey = backgroundSelect.value;
    selectedColor = '';
    applyBackground(backgroundMappings[selectedBackgroundKey]);
});

// Utility functions
function toggleVisibility(elements) {
    elements.forEach(element => {
        if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
        } else {
            element.classList.add('hidden');
        }
    });
}

function hideElements(elements) {
    elements.forEach(element => {
        element.classList.add('hidden');
    });
}

function applyBackground(color) {
    modelViewer.style.background = color;
}
</script>




          
          
<!-- Div for the slider with label -->
  <div class="slider-container hidden">
    <label for="exposureSlider"style="color: white;">Exposure:</label>
    <input type="range" id="exposureSlider" min="0" max="2" step="0.1" value="1">
  </div>


<!-- Div for the auto-rotate toggle button with label -->
<div class="auto-rotate-container hidden">
  <label for="autoRotateToggle" style="color: white;">Auto-Rotate:</label>
  <input type="checkbox" id="autoRotateToggle" checked>
</div>


<!-- Div for the camera-orbit toggle button with label -->
<div class="camera-orbit-container hidden">
    <label for="cameraOrbitToggle" style="color: white;">Lock Bottom View:</label>
    <input type="checkbox" id="cameraOrbitToggle">
</div>


          
<!-- Div for the AR Placement toggle buttons with label -->
<div class="ar-placement-container hidden">
  <label style="color: white; display: block;">AR Placement:</label>
  <div>
    <div style="display: flex; align-items: center; margin-bottom: 2px;"> <!-- Adjusted spacing between options -->
      <input type="radio" id="floorToggle" name="arPlacement" value="floor" checked style="margin-right: 5px;">
      <label for="floorToggle" style="color: white; margin-right: 10px;">Floor</label>
    </div>
    <div style="display: flex; align-items: center; margin-top: -2px;"> <!-- Negative margin to move "Wall" up -->
      <input type="radio" id="wallToggle" name="arPlacement" value="wall" style="margin-right: 5px;">
      <label for="wallToggle" style="color: white;">Wall (beta)</label>
    </div>
  </div>
</div>


          
<script>
document.addEventListener('DOMContentLoaded', () => {
  const modelViewer = document.getElementById('model');
  const cameraOrbitToggle = document.getElementById('cameraOrbitToggle');

  cameraOrbitToggle.addEventListener('change', (event) => {
    if (event.target.checked) {
      modelViewer.setAttribute('min-camera-orbit', 'auto 50% 100%');
      modelViewer.setAttribute('max-camera-orbit', 'auto 50% 100%');
    } else {
      modelViewer.setAttribute('min-camera-orbit', 'auto auto 100%');
      modelViewer.setAttribute('max-camera-orbit', 'auto auto 100%');
    }
  });
});
</script>
   

  <!-- Shape div for background -->
  <div class="background-container hidden"></div>



          
  <!-- pro button -->
  <div class="pro-button">
  
      <img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/upgrade2f.png" alt="pro" id="pro-button-img">

  </div>
          
  <script>
    document.getElementById('pro-button-img').onclick = function() {
      window.open('https://www.placeme.gr/viewar-home/#block-yui_3_17_2_1_1714998261743_8351', '_blank');
    };
  </script>

          


  <!-- logo button -->
  <div class="logo-button">
  
      <img src="https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/viewar-f2c.png" alt="logo" id="logo-button-img">

  </div>

  <script>
    document.getElementById('logo-button-img').onclick = function() {
      window.open('https://www.placeme.gr', '_blank');
    };
  </script>

          

<div id="viewinar-button-container" class="viewinar-button-container">
  <div class="viewinar-content">
    <div class="viewinar-button">
      <img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/viewinar4.png" alt="viewinar" id="viewinar-button-img">
    </div>
  </div>
</div>




          
          


<div class="dropbox-upload-button disabled" id="dropbox-upload-button-container">
    <img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/unique-url.png" alt="Upload to Dropbox" id="dropbox-upload-button" onclick="uploadToDropbox();" class="dropbox-upload-button-img">
    <span class="tooltip-text">Share & embed</span>
</div>


<div id="title" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); font-size: 20px; color: #a9a9a9; z-index: -1; text-align: center; pointer-events: none;">
    Drag & drop or upload a GLB / glTF model.<br>
    For USDZ models, use the upload button.
</div>


 
          
<!-- URL Display Box -->
<div id="url-display" class="hidden">
    <h2 id="url-title" style="display: none; font-size: smaller;">Shared Link:</h2>
    <div id="copy-button-container">
        <button id="copy-url-button" style="display: none;" onclick="copyToClipboard('generated-url')">Copy</button>
        <input type="text" id="generated-url" style="display: none;" readonly>
    </div>
    <h2 id="iframe-url-title" style="display: none; font-size: smaller;">Embed Code:</h2>
    <div id="iframe-copy-button-container">
        <button id="copy-iframe-url-button" style="display: none;" onclick="copyToClipboard('generated-iframe-url')">Copy</button>
        <input type="text" id="generated-iframe-url" style="display: none;" readonly>
    </div>
    <h2 id="qr-title" style="display: none; font-size: smaller;">Scan to view in AR:</h2>
    <div id="qr-code-wrapper" class="hidden">
        <div id="qr-code-container"></div>
    </div>
 <span id="url-generating" style="display: none;">
  Generating link <span class="spinner"></span>
</span>
</div>


<style>
/* CSS for the spinner */
.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid rgba(0, 0, 0, 0.2);
  border-top-color: #df8378; /* Updated color */
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
  margin-left: 5px;
  vertical-align: middle;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}


</style>
          

<script>

  
  function copyToClipboard(elementId) {
  var copyText = document.getElementById(elementId);
  copyText.style.display = 'block';
  copyText.select();
  copyText.setSelectionRange(0, 99999); // For mobile devices
  document.execCommand('copy');
  copyText.style.display = 'none';
}

document.getElementById('copy-url-button').addEventListener('click', function() {
  copyToClipboard('generated-url');
  this.textContent = 'Copied';
  setTimeout(() => {
    this.textContent = 'Copy';
  }, 2000);
});

document.getElementById('copy-iframe-url-button').addEventListener('click', function() {
  copyToClipboard('generated-iframe-url');
  this.textContent = 'Copied';
  setTimeout(() => {
    this.textContent = 'Copy';
  }, 2000);
});

</script>




          


<script>
 document.querySelectorAll('.dropbox-upload-button, .upload-button, .toggle-button, .spectrum-button').forEach(button => {
    const tooltip = button.querySelector('.tooltip-text');

    button.addEventListener('click', () => {
        if (tooltip) {
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '0';
        }
    });

    button.addEventListener('mouseleave', () => {
        if (tooltip) {
            tooltip.style.visibility = '';
            tooltip.style.opacity = '';
        }
    });
});

    </script>



          
 <script>

   
 const backgroundMappings = {
    "none": "none",  // No background
    "mg": "linear-gradient(#ffffff, #ada996)",  // Misty Morning
    "tg": "linear-gradient(#009966, #cce5d2)", // Tranquil Garden
    "sd": "linear-gradient(#fceabb, #f8b500)",  // Sunny Day
    "ob": "linear-gradient(#aed6dc, #5b7876)",  // Ocean Breeze
    "sm": "linear-gradient(#f9fbe7, #a8d4b0)",  // Spring Meadow
    "mn": "linear-gradient(#eddcd2, #5a5759)",  // Moonlit Night
    "nd": "linear-gradient(#ff0081, #9c1d86, #5a2a8b, #1f3c88)",  // Neon Dream
    "dm": "linear-gradient(#c79081, #dfa579)",  // Desert Mirage
    "ds": "linear-gradient(#000428, #004e92)",  // Deep Space
    "sg": "linear-gradient(#ff9966, #ff5e62)"   // Sunset Glow
};

document.getElementById('background-select').addEventListener('change', function() {
    var selectedBackgroundKey = this.value;
    var modelViewer = document.getElementById('model');
    var background = backgroundMappings[selectedBackgroundKey];

    // Clear the selected color
    selectedColor = '';

    // Set the background
    modelViewer.style.background = background;
});



   
   var modelFile;
    var viewLimit = 20; // Set the daily view limit here

    // Function to reset view count if needed
    function resetViewsIfNeeded() {
        const timeLimit = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        var lastViewTime = parseInt(localStorage.getItem('lastViewTime')) || 0;
        var currentTime = new Date().getTime();
        if (currentTime - lastViewTime > timeLimit) {
            localStorage.setItem('viewCount', 0);
            localStorage.setItem('lastViewTime', currentTime);
        }
    }

    // Function to check and update view count
    function updateViewCount() {
        resetViewsIfNeeded();
        var viewCount = parseInt(localStorage.getItem('viewCount')) || 0;
        if (viewCount >= viewLimit) {
            alert("Daily view limit reached. Please try again tomorrow or upgrade to ViewAR Pro for unlimited views.");
            return false;
        }
        viewCount++;
        localStorage.setItem('viewCount', viewCount.toString());
        return true;
    }


 
 function copyToClipboard(elementId) {
    var copyText = document.getElementById(elementId);
    copyText.style.display = 'inline'; // Ensure it's visible before copying
    copyText.select();
    copyText.setSelectionRange(0, 99999); // For mobile devices
    document.execCommand('copy');
    // Do not hide the element after copying
}

document.getElementById('copy-url-button').addEventListener('click', function() {
    copyToClipboard('generated-url');
    this.textContent = 'Copied';
    setTimeout(() => {
        this.textContent = 'Copy';
    }, 2000);
});

document.getElementById('copy-iframe-url-button').addEventListener('click', function() {
    copyToClipboard('generated-iframe-url');
    this.textContent = 'Copied';
    setTimeout(() => {
        this.textContent = 'Copy';
    }, 2000);
});


  let selectedUSDZURL = "";

  function generateIframeURL(modelURL) {

  // Get the auto-rotate setting
          var autoRotate = document.getElementById('autoRotateToggle').checked;
            var selectedBackgroundKey = document.getElementById('background-select').value;

          var cameraOrbit = document.getElementById('cameraOrbitToggle').checked ? 'auto 50% 100%' : 'auto auto 100%';
          var exposureValue = document.getElementById('exposureSlider').value;

             var arPlacement = floorToggle.checked ? 'floor' : 'wall';

    
      var pathFromDropbox = modelURL.split('https://dl.dropboxusercontent.com/')[1];
      var uniqueURL = 'https://www.placeme.gr/viewar-url?m=' + encodeURIComponent(pathFromDropbox) + '&r=' + autoRotate + '&b=' + encodeURIComponent(selectedBackgroundKey) + '&co=' + encodeURIComponent(cameraOrbit) + '&e=' + encodeURIComponent(exposureValue) + '&cl=' + encodeURIComponent(selectedColor) + '&ar=' + encodeURIComponent(arPlacement);
      
        // Append the USDZ parameter if available
  if (typeof selectedUSDZURL !== 'undefined' && selectedUSDZURL) {
    uniqueURL += '&usdz=' + encodeURIComponent(selectedUSDZURL);
  }
      
      var iframeURL = '<iframe src="' + uniqueURL + '" width="100%" height="600px" scrolling="no" style="overflow: hidden; border:none;"></iframe>';
      return iframeURL;
  }

  function displayURLs(uniqueURL, iframeURL) {
      var urlInput = document.getElementById('generated-url');
      var iframeUrlInput = document.getElementById('generated-iframe-url');

      urlInput.value = uniqueURL;
      iframeUrlInput.value = iframeURL;

      urlInput.style.display = 'inline';
      iframeUrlInput.style.display = 'inline';

      var copyButtonContainer = document.getElementById('copy-button-container');
      var iframeCopyButtonContainer = document.getElementById('iframe-copy-button-container');
      var copyButton = document.getElementById('copy-url-button');
      var iframeCopyButton = document.getElementById('copy-iframe-url-button');

      // Make the containers and buttons visible
      copyButtonContainer.style.display = 'flex';
      iframeCopyButtonContainer.style.display = 'flex';
      copyButton.style.display = 'inline';
      iframeCopyButton.style.display = 'inline';

      var urlTitle = document.getElementById('url-title');
      var iframeUrlTitle = document.getElementById('iframe-url-title');
      var qrTitle = document.getElementById('qr-title');  // Get the QR title element

      urlTitle.style.display = 'block';
      iframeUrlTitle.style.display = 'block';
      qrTitle.style.display = 'block'; // Display the QR title

      // Generate and display QR Code
      var qrContainer = document.getElementById('qr-code-container');
      var qrWrapper = document.getElementById('qr-code-wrapper');
      if (qrContainer) {
          qrContainer.innerHTML = ''; // Clear previous QR code, if any
          new QRCode(qrContainer, {
              text: uniqueURL,
              width: 100,
              height: 100,
              colorDark: "#000000",
              colorLight: "#ffffff",
              correctLevel: QRCode.CorrectLevel.L
          });
          qrContainer.style.display = 'block'; // Make sure to show the QR code container
        qrWrapper.style.display = 'flex'; // Make sure to show the QR code container
          qrWrapper.classList.remove('hidden'); // Show the wrapper when QR is generated
      }
  }


  

    // Function to handle dragover event
    function dragover_handler(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Function to handle dropped model
    function loadDroppedModel(event) {
        event.preventDefault();
        if (!updateViewCount()) return;  // Check view limit before loading model
        validateFile(event.dataTransfer.files[0]);

        // Hide the viewinar button container
        hideViewinarButton();
    }

    // Function to load a model uploaded through the file input
    function loadUploadedModel(event) {
        if (!updateViewCount()) return;  // Check view limit before loading model
        validateFile(event.target.files[0]);
    }

    // Function to validate file size and type
    function validateFile(file) {
        const fileLimit = 20 * 1024 * 1024; // 20 MB in bytes
        if (file.size > fileLimit) {
            alert("File is too large. Upload a file smaller than 20 MB, or upgrade to ViewAR Pro to view files up to 500 MB.");
            return;
        }

        if (!file.name.match(/\.(gltf|glb)$/)) {
            alert("Unsupported file format. Please use GLB or GLTF files only. You can convert other 3D formats using our free ConvertAR tool.");
            return;
        }

        // Update global modelFile with the validated file
        modelFile = file;
        loadModel(file);
    }

    // Function to load the model once it's validated
    function loadModel(file) {
        var url = URL.createObjectURL(file);
        var model = document.getElementById('model');
        if (model) {
            model.src = url;

            // Hide UI elements related to URL and upload button
            hideUI();

            // Hide the viewinar button container
            hideViewinarButton();
        }
    }


// Function to load a model uploaded through the file input
function loadUploadedModel(event) {
  if (!updateViewCount()) return;  // Check view limit before loading model
  validateFile(event.target.files[0]); // validates glb/gltf and then calls loadModel(file)
}

function loadUploadedUSDZModel(event) {
  if (!updateViewCount()) return;  // Check view limit before loading model
  validateUSDZFile(event.target.files[0]); // validates the file then calls loadUSDZModel(file)
}

function validateUSDZFile(file) {
  const fileLimit = 20 * 1024 * 1024; // 20 MB
  if (file.size > fileLimit) {
    alert("File is too large. Upload a file smaller than 20 MB, or upgrade to ViewAR Pro to view files up to 500 MB.");
    return;
  }
  if (!file.name.match(/\.usdz$/i)) {
    alert("Unsupported file format. Please use USDZ files only.");
    return;
  }
  loadUSDZModel(file);
}

function loadUSDZModel(file) {
  var url = URL.createObjectURL(file);
  var model = document.getElementById('model'); // assuming model-viewer element has id 'model'
  if (model) {
    model.setAttribute("ios-src", url); // update the ios-src attribute instead of src

    // Hide UI elements related to URL and upload button
    
    hideViewinarButton();
  }
}

    // Function to hide the viewinar button container
    function hideViewinarButton() {
        var buttonContainer = document.querySelector('.viewinar-button-container');
        if (buttonContainer) {
            buttonContainer.style.display = 'none';
        }
    }

    // Function to hide various UI components
  function hideUI() {
    var elementsToHide = [
        'copy-button-container',
        'iframe-copy-button-container',
        'url-title',
        'iframe-url-title',
        'generated-url',
        'generated-iframe-url',
        'copy-url-button',
        'copy-iframe-url-button',
        'title',
        'qr-code-container',
        'qr-title',
        'content-wrapper',
      'qr-code-wrapper'
        
    ];

    elementsToHide.forEach(function(id) {
        var element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });

    var dropboxButtonContainer = document.getElementById('dropbox-upload-button-container');
    if (dropboxButtonContainer) {
        dropboxButtonContainer.classList.remove('disabled');
        dropboxButtonContainer.style.opacity = '1';
        dropboxButtonContainer.style.pointerEvents = 'auto';
    }
}


    // Event listener setup
    document.addEventListener('DOMContentLoaded', function() {
        document.body.addEventListener('dragover', dragover_handler);
        var fileUpload = document.getElementById('file-upload');
        if (fileUpload) {
            fileUpload.addEventListener('change', loadUploadedModel);
        }
        resetViewsIfNeeded(); // Reset view count on page load if necessary
    });



async function refreshAccessToken() {
    try {
        const response = await fetch('https://starter-1-5nklw2srk-nicks-projects-baae8e06.vercel.app/api/refresh-token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ action: 'refresh' })
        });

        if (!response.ok) {
            throw new Error('Failed to refresh token');
        }

        const data = await response.json();
        return data.accessToken;
    } catch (error) {
        console.error('Error refreshing token:', error);
    }
}



async function getCurrentAccessToken() {
    try {
        const response = await fetch('https://starter-1-5nklw2srk-nicks-projects-baae8e06.vercel.app/api/refresh-token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ action: 'current' })
        });

        if (!response.ok) {
            throw new Error('Failed to get current access token');
        }

        const data = await response.json();
        return data.accessToken;
    } catch (error) {
        console.error('Error getting current access token:', error);
    }
}



   

  function uploadToDropbox() {
    if (!modelFile) {
        alert("Upload a GLB / glTF file first.");
        return;
    }
    if (modelFile.size > 5242880) { // 5 MB in bytes
        alert("File is too large. Maximum file size for shared models is 5 MB. Upgrade to ViewAR Pro to share & embed models up to 50 MB.");
        return;
    }

        // Validate USDZ file size upfront if it exists
    if (typeof usdzFile !== 'undefined' && usdzFile && usdzFile.size > 5242880) {
        alert("USDZ file is too large. Maximum file size for shared models is 5 MB.");
        return;
    }

    // Disable the button to prevent multiple uploads
    document.getElementById('dropbox-upload-button-container').classList.add('disabled');
    document.getElementById('dropbox-upload-button-container').style.pointerEvents = 'none';
    document.getElementById('url-generating').style.display = 'inline'; // Show "Generating URL" text
    document.getElementById('dropbox-upload-button-container').style.opacity = '0.5'; // Set opacity to 0.5

    // Get the required elements and parameters
    var autoRotate = document.getElementById('autoRotateToggle').checked;
    // Get the selected background
    const backgroundParam = selectedBackgroundKey ? selectedBackgroundKey : selectedColor;
    var cameraOrbit = document.getElementById('cameraOrbitToggle').checked ? 'auto 50% 100%' : 'auto auto 100%';
    var exposureValue = document.getElementById('exposureSlider').value;
    var floorToggle = document.getElementById('floorToggle'); // Ensure this element exists
    var arPlacement = floorToggle.checked ? 'floor' : 'wall';

async function handleUpload(accessToken) {
    function getRandomString(length) {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }

    // Generate a unique and sanitized file name for the GLB/GLTF model
    const originalFileName = modelFile.name.split('.')[0];
    const fileExtension = modelFile.name.split('.')[1];
    const sanitizedFileName = originalFileName.replace(/[^a-zA-Z0-9-_]/g, '-');
    const uniqueFileName = sanitizedFileName + '-' + getRandomString(6) + '.' + fileExtension;

    try {
        // Upload the GLB/GLTF model file
        const uploadResponse = await fetch('https://content.dropboxapi.com/2/files/upload', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Dropbox-API-Arg': JSON.stringify({
                    path: '/model-uploads/' + uniqueFileName,
                    mode: 'add',
                    autorename: false,
                    mute: false
                }),
                'Content-Type': 'application/octet-stream'
            },
            body: modelFile
        });

        if (!uploadResponse.ok && uploadResponse.status === 401) {
            const newAccessToken = await refreshAccessToken();
            return handleUpload(newAccessToken);
        }

        const uploadData = await uploadResponse.json();

        // Create shared link for the GLB/GLTF model file
        const sharedLinkResponse = await fetch('https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                path: uploadData.path_display,
                settings: {
                    requested_visibility: 'public'
                }
            })
        });

        if (!sharedLinkResponse.ok) {
            throw new Error(`HTTP error! status: ${sharedLinkResponse.status}`);
        }

        const sharedLinkData = await sharedLinkResponse.json();

        var modelURL = sharedLinkData.url
          .replace('www.dropbox.com', 'dl.dropboxusercontent.com')
          .replace('?dl=0', '?dl=1');
        var pathFromDropbox = modelURL.split('https://dl.dropboxusercontent.com/')[1];
        var uniqueURL = 'https://www.placeme.gr/viewar-url?m=' + encodeURIComponent(pathFromDropbox) +
            '&r=' + autoRotate +
            '&b=' + encodeURIComponent(selectedBackgroundKey) +
            '&co=' + encodeURIComponent(cameraOrbit) +
            '&e=' + encodeURIComponent(exposureValue) +
            '&cl=' + encodeURIComponent(selectedColor) +
            '&ar=' + encodeURIComponent(arPlacement);

       

// Initialize jsonData with a default usdzURL property so it exists.
var jsonData = {
    "pathFromDropbox": pathFromDropbox,
    "autoRotate": autoRotate,
    "selectedBackgroundKey": selectedBackgroundKey,
    "cameraOrbit": cameraOrbit,
    "exposureValue": exposureValue,
    "selectedColor": selectedColor,
    "arPlacement": arPlacement,
    "uniqueURL": uniqueURL,  // initially without USDZ
    "usdzURL": "" // default value
};

// NEW: If a USDZ file was also uploaded, upload it now.
if (typeof usdzFile !== 'undefined' && usdzFile) {
    const originalUSDZFileName = usdzFile.name.split('.')[0];
    const usdzExtension = usdzFile.name.split('.')[1];
    const sanitizedUSDZFileName = originalUSDZFileName.replace(/[^a-zA-Z0-9-_]/g, '-');
    const uniqueUSDZFileName = sanitizedUSDZFileName + '-' + getRandomString(6) + '.' + usdzExtension;

    const uploadUSDZResponse = await fetch('https://content.dropboxapi.com/2/files/upload', {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Dropbox-API-Arg': JSON.stringify({
                path: '/model-uploads/' + uniqueUSDZFileName,
                mode: 'add',
                autorename: false,
                mute: false
            }),
            'Content-Type': 'application/octet-stream'
        },
        body: usdzFile
    });

    if (!uploadUSDZResponse.ok && uploadUSDZResponse.status === 401) {
        const newAccessToken = await refreshAccessToken();
        // For simplicity, assume success on retry.
    }

    const uploadUSDZData = await uploadUSDZResponse.json();

    const sharedLinkUSDZResponse = await fetch('https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings', {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            path: uploadUSDZData.path_display,
            settings: {
                requested_visibility: 'public'
            }
        })
    });

    if (!sharedLinkUSDZResponse.ok) {
        throw new Error(`HTTP error! status: ${sharedLinkUSDZResponse.status}`);
    }

    const sharedLinkUSDZData = await sharedLinkUSDZResponse.json();

var fullUSDZURL = sharedLinkUSDZData.url
  .replace('www.dropbox.com', 'dl.dropboxusercontent.com')
  .replace('?dl=0', '?dl=1');
var usdzPath = fullUSDZURL.split('https://dl.dropboxusercontent.com/')[1];
// Do not remove the query string:
jsonData.usdzURL = usdzPath;  // Now includes '?dl=1'
jsonData.usdzDropboxPath = '/model-uploads/' + uniqueUSDZFileName;  // Exact path used for upload

selectedUSDZURL = jsonData.usdzURL;



}

// Append USDZ parameter to uniqueURL only if jsonData.usdzURL is not empty.
if (jsonData && jsonData.usdzURL !== "") {
    uniqueURL += '&usdz=' + encodeURIComponent(jsonData.usdzURL);
}

// Update jsonData.uniqueURL so that it now contains the complete URL.
jsonData.uniqueURL = uniqueURL;

// Now convert jsonData to a JSON string.
var jsonString = JSON.stringify(jsonData);

// Upload JSON file to Dropbox
const jsonFileName = uniqueFileName.replace(/\.[^/.]+$/, '') + '.json';

const jsonUploadResponse = await fetch('https://content.dropboxapi.com/2/files/upload', {
    method: 'POST',
    headers: {
        'Authorization': 'Bearer ' + accessToken,
        'Dropbox-API-Arg': JSON.stringify({
            path: '/model-uploads/' + jsonFileName,
            mode: 'add',
            autorename: false,
            mute: false
        }),
        'Content-Type': 'application/octet-stream'
    },
    body: jsonString
});

if (!jsonUploadResponse.ok) {
    throw new Error(`Failed to upload JSON file. HTTP status ${jsonUploadResponse.status}`);
}

var iframeURL = generateIframeURL(modelURL);

// Proceed to display URLs and QR code
displayURLs(uniqueURL, iframeURL);


// Clear the USDZ file variable
usdzFile = undefined;

// Reset the USDZ file input element
document.getElementById('usdzInput').value = '';


        document.getElementById('url-generating').style.display = 'none';
        document.getElementById('dropbox-upload-button-container').style.opacity = '1';
        document.getElementById('dropbox-upload-button').disabled = true;
        document.getElementById('dropbox-upload-button-container').style.pointerEvents = 'none';

    } catch (error) {
        console.error('Error in handleUpload:', error);
        document.getElementById('dropbox-upload-button-container').classList.remove('disabled');
        document.getElementById('url-generating').style.display = 'none';
        document.getElementById('dropbox-upload-button-container').style.opacity = '1';
        document.getElementById('dropbox-upload-button-container').style.pointerEvents = 'auto';
    }
}


    getCurrentAccessToken().then(currentAccessToken => {
        handleUpload(currentAccessToken);
    });
}



 </script>


  <div id="buttonContainer">
      <button id="playPauseButton" class="controlButton">
        <img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/pause-play-button-f.png" alt="Play/Pause">
      </button>
      <button id="resetButton" class="controlButton">
        <img src="https://cdn.glitch.global/4da88eb2-b08b-43af-a732-a357fa49b917/reset-button-f2.png" alt="Reset">
      </button>
    </div>


</model-viewer>

<style>
  #buttonContainer {
    position: absolute;
    bottom: 0px;
    width: 100%;
    text-align: center;
    margin-bottom: 10px;
  }

  .controlButton {
    margin: 0 5px;
    border: none; /* Remove the default border */
    padding: 0; /* Remove default padding */
    background: none; /* Remove default background */
    cursor: pointer; /* Add pointer cursor on hover */
  }

  .controlButton img {
    width: 50px;  /* Set the image width */
    height: 50px; /* Set the image height */
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Get references to the model-viewer and the control buttons
  const modelViewer = document.getElementById('model');
  const buttonContainer = document.getElementById('buttonContainer');
  const playPauseButton = document.getElementById('playPauseButton');
  const resetButton = document.getElementById('resetButton');

  // Hide the button container initially.
  buttonContainer.style.display = 'none';

  // Listen for the model load event.
  modelViewer.addEventListener('load', () => {
    // Check for available animations.
    const animations = modelViewer.availableAnimations;
    if (animations && animations.length > 0) {
      // If animations exist, show the buttons.
      buttonContainer.style.display = 'block';
    } else {
      // If no animations, keep buttons hidden.
      buttonContainer.style.display = 'none';
    }
  });

  // Play/Pause toggle logic.
  playPauseButton.addEventListener('click', () => {
    if (modelViewer.paused) {
      modelViewer.play();
    } else {
      modelViewer.pause();
    }
  });

  // Reset animation to the beginning.
  resetButton.addEventListener('click', () => {
    modelViewer.pause();
    modelViewer.currentTime = 0;
  });
});
</script>




<script>
window.addEventListener('DOMContentLoaded', (event) => {
    var urlParams = new URLSearchParams(window.location.search);
    var modelPath = urlParams.get('model'); // Get the 'model' query parameter

    if (modelPath) {
        var completeModelURL = 'https://dl.dropboxusercontent.com/' + decodeURIComponent(modelPath);
        var modelViewer = document.getElementById('model');
        if (modelViewer) {
            modelViewer.src = completeModelURL; // Set the new src for the model-viewer
        }
    }
});
</script>
      

<script>
// Get the menu button and other buttons
const menuButton = document.getElementById("menu-button");
const toggle = document.querySelector('.toggle-button');
const upload = document.querySelector('.upload-button');
const texture = document.querySelector('.upload-controls');

const link = document.querySelector('.dropbox-upload-button');

// Add click event listener to the menu button
menuButton.addEventListener('click', function() {
  // Toggle the visibility of other buttons
  toggle.classList.toggle('hidden');
  upload.classList.toggle('hidden');
  texture.classList.toggle('hidden');
 
  link.classList.toggle('hidden');

  // Change the image src based on the visibility of other buttons
  const menuButtonImg = document.getElementById('menu-button-img');
  if (!toggle.classList.contains('hidden') || !upload.classList.contains('hidden') || !texture.classList.contains('hidden') || !link.classList.contains('hidden')) {
    menuButtonImg.src = 'https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/menu-on-f2.png';
  } else {
    menuButtonImg.src = 'https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/menu-on-f.png';
  }
});

</script>

 

<script>
function toggleSettings() {
  var controls = document.querySelector('.controls');
  var dropdownContainer = document.querySelector('.dropdown-container');
  var toggleButtonImg = document.getElementById('toggle-button-img');
  var sliderContainer = document.querySelector('.slider-container');
  var autoRotateContainer = document.querySelector('.auto-rotate-container');
  var cameraOrbitContainer = document.querySelector('.camera-orbit-container');
  var arPlacementContainer = document.querySelector('.ar-placement-container'); 
  var backgroundContainer = document.querySelector('.background-container');
  var urlDisplay = document.getElementById('url-display');
  


  controls.classList.toggle('hidden');
  dropdownContainer.classList.toggle('hidden');
  sliderContainer.classList.toggle('hidden');
  autoRotateContainer.classList.toggle('hidden');
  cameraOrbitContainer.classList.toggle('hidden');
  arPlacementContainer.classList.toggle('hidden');
  backgroundContainer.classList.toggle('hidden');
  urlDisplay.classList.toggle('hidden');
 
  

  if (controls.classList.contains('hidden')) {
    toggleButtonImg.src = 'https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/set-f2.png';
  } else {
    toggleButtonImg.src = 'https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/setb-f2.png';
  }
}

document.querySelector('.toggle-button').addEventListener('click', toggleSettings);

document.getElementById('dropbox-upload-button').addEventListener('click', function() {
  var controls = document.querySelector('.controls');

  if (!controls.classList.contains('hidden')) {
    toggleSettings();
  }

  var urlDisplay = document.getElementById('url-display');
  urlDisplay.classList.remove('hidden');
});

document.getElementById('background-select').addEventListener('change', function() {
            var selectedBackgroundKey = this.value;
            var modelViewer = document.getElementById('model');
            var background = backgroundMappings[selectedBackgroundKey];
            modelViewer.style.background = background;
        });

document.getElementById('exposureSlider').addEventListener('input', function() {
  var modelViewer = document.getElementById('model');
  modelViewer.setAttribute('exposure', this.value);
});

document.getElementById('autoRotateToggle').addEventListener('change', function() {
  var modelViewer = document.getElementById('model');
  modelViewer.autoRotate = this.checked;
});





  
document.addEventListener('DOMContentLoaded', function() {
  var floorToggle = document.getElementById('floorToggle');
  var wallToggle = document.getElementById('wallToggle');
  var modelViewer = document.getElementById('model');

  function updateArPlacement() {
    if (floorToggle.checked) {
      modelViewer.setAttribute('ar-placement', 'floor');
    } else if (wallToggle.checked) {
      modelViewer.setAttribute('ar-placement', 'wall');
    }
  }

  floorToggle.addEventListener('change', updateArPlacement);
  wallToggle.addEventListener('change', updateArPlacement);
});


  
  

document.addEventListener('click', function(event) {
  var backgroundContainer = document.querySelector('.background-container');
  var toggleButton = document.querySelector('.toggle-button');
  var controls = document.querySelector('.controls');
  var dropdownContainer = document.querySelector('.dropdown-container');
  var sliderContainer = document.querySelector('.slider-container');
  var autoRotateContainer = document.querySelector('.auto-rotate-container');
  var cameraOrbitContainer = document.querySelector('.camera-orbit-container');
  var arPlacementContainer = document.querySelector('.ar-placement-container'); 
  var urlDisplay = document.getElementById('url-display');
   

  if (!backgroundContainer.contains(event.target) && 
      !toggleButton.contains(event.target) &&
      !controls.contains(event.target) &&
      !dropdownContainer.contains(event.target) &&
      !sliderContainer.contains(event.target) &&
      !autoRotateContainer.contains(event.target) &&
      !cameraOrbitContainer.contains(event.target) &&
      !arPlacementContainer.contains(event.target) &&
      !urlDisplay.contains(event.target)) {
    if (!backgroundContainer.classList.contains('hidden')) {
      toggleSettings();
    }
  }
});

</script>



<style>

@media (max-width: 600px) {
        #title {
            display: none;
        }
    }

  #ar-button {
    position: absolute;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2;
    width: 180px; /* Adjust as needed */
  }




  model-viewer {
  --progress-bar-color: darkorange;
   --progress-bar-height: 2.5px;
}
  

  .menu-button {
   position: absolute;
    top: 10px;
    left: 10px;
    z-index: 2;
}

.menu-button img {
  width: 45px; /* Adjust as needed */
  height: 45px; /* Adjust as needed */
  cursor: pointer;
}

  
  .pro-button {
   position: absolute;
    top: 40px;
    right: 7px;
    z-index: 2;
}

.pro-button img {
    width: 130px; /* Adjust as needed */
    height: 100%; /* Adjust as needed */
  cursor: pointer;
}



#url-display {
    position: absolute;
    top: 185px;
    left: 10px;
    z-index: 10;
    width: calc(25%); /* Adjust width to ensure it fits in the remaining space */
    display: flex;
    flex-direction: column;
    align-items: stretch; /* Make sure items stretch to fill the width */
}

#copy-button-container, #iframe-copy-button-container {
    display: flex;
    width: 100%; /* Ensure these containers take the full width of their parent */
    align-items: center;
}

#generated-url, #generated-iframe-url {
    flex-grow: 1;
    margin-left: 10px; /* Add some space between the button and the input */
    width: auto; /* This should allow the input to expand as needed */
}

button {
    width: auto; /* Ensure buttons don't stretch unnecessarily */
}

.hidden {
    display: none !important;
}

#copy-url-button, #copy-iframe-url-button {
    display: inline-block;
    background-color: black;
    color: orange;
    border: none;
    border-radius: 10px;
    padding: 10px 0; /* Adjust padding as needed */
    font-size: 16px; /* Make the font size smaller */
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease;
    font-family: 'Proxima Nova', sans-serif;
    width: 80%; /* Set a percentage width */
    max-width: 120px; /* Ensure it does not grow too large */
    min-width: 80px; /* Ensure it does not shrink too small */
    height: 40px; /* Set a fixed height */
    text-align: center; /* Center the text */
    line-height: 20px; /* Adjust line height to center text vertically */
    white-space: nowrap; /* Prevent text from wrapping */
    overflow: hidden; /* Hide overflow */
    text-overflow: ellipsis; /* Add ellipsis if text overflows */
}

#copy-url-button:hover, #copy-iframe-url-button:hover {
    background-color: orange;
    color: black;
}



  



#qr-code-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 110px; /* Adjusted width to fit the QR code plus padding */
    height: 110px; /* Adjusted height to fit the QR code plus padding */
    padding: 5px;
    border: 2px solid transparent; /* Transparent border to show the gradient */
    border-radius: 15px;
    margin-top: 10px;
    background-color: white;
    background-clip: padding-box; /* To apply the gradient to the border */
    position: relative;
}

#qr-code-wrapper::before {
    content: '';
    position: absolute;
    top: -2px; /* Adjust to match the border width */
    left: -2px; /* Adjust to match the border width */
    right: -2px; /* Adjust to match the border width */
    bottom: -2px; /* Adjust to match the border width */
    border-radius: 17px; /* Adjust to match the border radius */
    background: linear-gradient(45deg, #ee7b73, #f3b17a); /* Gradient border */
    z-index: -1; /* Place the gradient behind the content */
}

#qr-code-container {
    width: 100px; /* Adjusted width for the QR code */
    height: 100px; /* Adjusted height for the QR code */
}





.dropbox-upload-button {
    position: absolute;
    top: 130px;
    left: 10px;
    z-index: 10;
    width: 45px;
    height: 45px;
    cursor: pointer;
}

.dropbox-upload-button.disabled {
    opacity: 0.5;
}

.dropbox-upload-button-img {
    width: 100%;
    height: 100%;
}


        .dropbox-upload-button .tooltip-text {
            visibility: hidden;
            width: 150px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            top: 50%;
            left: 105%; /* Position to the right of the button */
            margin-left: 10px; /* Add some space between the button and tooltip */
            transform: translateY(-50%); /* Center the tooltip vertically */
            opacity: 0;
            transition: opacity 0.3s;
        }

        .dropbox-upload-button .tooltip-text::after {
            content: "";
            position: absolute;
            top: 50%;
            right: 100%; /* Arrow on left */
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #555 transparent transparent;
            transform: translateY(-50%); /* Center the arrow vertically */
        }

        .dropbox-upload-button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }  


.ar-mode {
    position: absolute;
    bottom: 130px; /* Adjust the position as needed */
    left: 10px; /* Adjust the position as needed */
    border: none;
    background: none;
    padding: 0;
    width: 45px;
    height: 45px;
  }

  .ar-mode img {
    width: 45px; /* Adjust as needed */
    height: auto; /* Adjust as needed */
    cursor: pointer;
  }
  

  
  .toggle-button {
    position: absolute;
    top: 70px;
    left: 10px;
    z-index: 2;
  }

  .toggle-button img {
    width: 45px; /* Adjust as needed */
    height: 45px; /* Adjust as needed */
    cursor: pointer;
  }


  
        .toggle-button .tooltip-text {
            visibility: hidden;
            width: 150px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            top: 40%;
            left: 105%; /* Position to the right of the button */
            margin-left: 10px; /* Add some space between the button and tooltip */
            transform: translateY(-50%); /* Center the tooltip vertically */
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toggle-button .tooltip-text::after {
            content: "";
            position: absolute;
            top: 50%;
            right: 100%; /* Arrow on left */
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #555 transparent transparent;
            transform: translateY(-50%); /* Center the arrow vertically */
        }

        .toggle-button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }




   .spectrum-button .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            top: 40%;
            right: 105%; /* Position to the left of the button */
            margin-right: 10px; /* Add some space between the button and tooltip */
            transform: translateY(-50%); /* Center the tooltip vertically */
            opacity: 0;
            transition: opacity 0.3s;
        }

        .spectrum-button .tooltip-text::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 100%; /* Arrow on right */
            rotate:180deg;
            margin-top: -10px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #555 transparent transparent;
            transform: translateY(-50%); /* Center the arrow vertically */
        }

        .spectrum-button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }




.background-container {
  position: relative; /* Change from absolute to relative */
  top: 10px;
  left: 65px;
  width: 200px;
  height: 460px;
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.3));
  border-radius: 10px;
  z-index: 0;
  outline: 2px solid lightgray; /* Added light gray outline */
}

.controls,
.dropdown-container,
.slider-container,
.auto-rotate-container,
.camera-orbit-container,
.ar-placement-container {
  position: absolute;
  left: 70px; /* Adjust as necessary for internal alignment */
  z-index: 1;
  background: none;
  padding: 5px;
}

.controls {
  top: 15px; /* Adjust relative to new container */
}

.dropdown-container {
  top: 85px; /* Adjusted for spacing */
}

.slider-container {
  
  top: 160px; /* Adjusted for spacing */
    left: 75px; /* Push the slider container 10px to the right */

    max-width: 175px; /* maximum width of the slider */
    overflow: hidden; /* Ensures nothing spills out */
    padding: 0; /* Remove any padding that might cause layout shift */
}
  
.auto-rotate-container {
  top: 215px; /* Adjusted for spacing */
  left: 75px; /* Push the auto-rotate container 10px to the right */

}


.camera-orbit-container {
  top: 285px;
  left: 75px;
}


.ar-placement-container {
  position: absolute;
  top: 355px; /* Adjust this value for the desired vertical spacing */
  left: 75px; /* Align with auto-rotate container */
  z-index: 1;
  background: none;
  padding: 5px;
}



  

.slider-container label,
.auto-rotate-container label,
.camera-orbit-container label {
  display: block;
}

.slider {
  width: 200px;
  height: 10px;
  transform: rotate(0deg);
}

#autoRotateToggle,
#cameraOrbitToggle {
  transform: scale(1.5);
}



.spectrum-button {
    position: absolute;
    top: 80px;
    right: 10px; /* Adjust the position as needed */
    z-index: 2;
  }


   .spectrum-button img {
    width: 40px; /* Adjust as needed */
    height: 40px; /* Adjust as needed */
    cursor: pointer;
  }

  .spectrum-button input[type="file"] {
    display: none;
  }

  .spectrum-button label {
    cursor: pointer;
  }



  





  

 .logo-button {
    position: absolute;
    top: 10px;
    right: 10px; /* Adjust the position as needed */
    z-index: 2;
  }

    .logo-button img {
    width: 125px; /* Adjust as needed */
    height: 100%; /* Adjust as needed */
    cursor: pointer;
  }

    .hidden {
    display: none;
  }

.upload-controls {
  position: absolute;
    bottom: 70px;
    left: 10px;
  height: 45px;
    z-index: 2;
}

#uploadButton {
  width: 45px; /* Adjust as needed */
  height: 45px; /* Adjust as needed */
  cursor: pointer;
}



/* Container for button with rounded square gradient outline */
.viewinar-button-container {
  position: absolute;
  bottom: 10px;
  left: 10px; /* Position at the bottom left with a 10px distance */
  z-index: 2;
  display: flex;
  justify-content: center;
  align-items: center;
}

.viewinar-content {
  position: relative; /* Needed for the pseudo-element */
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px; /* Increase padding to add space between button and outline */
  background-color: white; /* Background color inside the container */
  border-radius: 15px; /* Rounded corners */
  overflow: hidden; /* Ensure pseudo-element stays within the container */
  width: 110px; /* Adjust to include padding */
  height: 110px; /* Adjust to include padding */
}

.viewinar-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 15px; /* Rounded corners */
  padding: 2px; /* Border width */
  background: linear-gradient(45deg, #ee7b73, #f3b17a); /* Gradient colors */
  -webkit-mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  mask-composite: exclude;
  pointer-events: none; /* Ensure pseudo-element does not interfere with interactions */
}

.viewinar-button {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100px; /* Adjust to fit the image and padding */
  height: 100px; /* Adjust to fit the image and padding */
}

.viewinar-button img {
  width: 100%; /* Ensure the image fills the container */
  height: auto; /* Maintain aspect ratio */
 
}




/* Media query to hide the button and text on mobile devices */
@media (max-width: 767px) {
  .viewinar-button-container {
    display: none;
  }
}





</style>

  

  <script 
    type="module">
    const modelViewerTexture1 = document.querySelector("model-viewer#model");
const uploadLabel = document.querySelector("#uploadLabel");
const uploadButton = document.querySelector("#uploadButton");

modelViewerTexture1.addEventListener("load", () => {
  const material = modelViewerTexture1.model.materials[0];

  const createAndApplyTexture = async (channel, file) => {
    const url = URL.createObjectURL(file);
    const texture = await modelViewerTexture1.createTexture(url);
    if (channel.includes("base") || channel.includes("metallic")) {
      material.pbrMetallicRoughness[channel].setTexture(texture);
    } else {
      material[channel].setTexture(texture);
    }
    uploadLabel.textContent = file.name;
    uploadLabel.style.display = "block";
  };

  // Add click event listener to the uploadButton
  uploadButton.addEventListener("click", () => {
    document.querySelector("#upload").click();
  });

  document.querySelector("#upload").addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (file) {
      createAndApplyTexture("baseColorTexture", file);
    }
  });
});


    </script>


      



<img id="my-image" src="https://cdn.glitch.global/58ebac90-6696-4495-bdc3-49c973e27c31/3d-viewer-ar-prompt-rounded-5.png" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; width: 350px; height: 520px;">

<script>
  const showImageButton = document.getElementById("armode");
  const arpromptImage = document.getElementById("arprompt");
  const myImage = document.getElementById("my-image");

  let showImage = false;

    if (/(android|iphone|ipad|ipod|iemobile|windows phone)/i.test(navigator.userAgent)) {
    showImageButton.style.display = "none";
  }

  showImageButton.addEventListener("click", () => {
    showImage = !showImage;
    if (showImage) {
      myImage.src = "https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/3d-viewer-ar-prompt-rounded-6.png";
      myImage.style.display = "block";
      arpromptImage.src = "https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/arb-f2.png";
    } else {
      myImage.src = "";
      myImage.style.display = "none";
      arpromptImage.src = "https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/ar-f2.png";
    }
  });

  document.addEventListener("click", (event) => {
    if (showImage && event.target !== showImageButton && event.target !== myImage && !showImageButton.contains(event.target)) {
      myImage.src = "";
      myImage.style.display = "none";
      showImage = false;
      arpromptImage.src = "https://cdn.glitch.global/88ef0bd7-9b9b-496a-87b5-4a5ce711f613/ar-f2.png";
    }
  });
</script>


<script>
  model.addEventListener('dragover', (event) => {
  event.preventDefault();
  model.addEventListener('drop', (event) => {
  event.preventDefault();
  const file = event.dataTransfer.files[0];
  const filename = file.name.toLowerCase();
  if (filename.match(/\.(stl)$/)) {
    var exporter = new THREE.GLTFExporter();
    var loader = new THREE.STLLoader();
    loader.load(URL.createObjectURL(file), (geometry) => {
      var material = new THREE.MeshStandardMaterial();
      var object = new THREE.Mesh(geometry,material);
      exporter.parse(object, (json) => {
        var string = JSON.stringify(json);
        var blob = new Blob([string], {type:'text/plain'});
        viewer.src = URL.createObjectURL(blob);
      } );
    } );
  }
});
</script>




<script>

const modelViewerVariants = document.querySelector("model-viewer#model");
const select = document.querySelector('#variant');

modelViewerVariants.addEventListener('load', () => {
  const names = modelViewerVariants.availableVariants;
    select.innerHTML = ''; // clear existing options
  for (const name of names) {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    select.appendChild(option);
  }
});

modelViewerVariants.addEventListener('model-visibility', () => {
  select.innerHTML = ''; // clear existing options
  const names = modelViewerVariants.availableVariants;
  for (const name of names) {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    select.appendChild(option);
  }
});

select.addEventListener('input', (event) => {
  modelViewerVariants.variantName = event.target.value === 'default' ? null : event.target.value;
});      
</script>







        <script src="./js/responsiveViewer.js"></script>
        <script src="./js/handleDrag.js"></script>
    </body>
</html>

<script>

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ResizeObserver = factory());
}(this, (function () { 'use strict';

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }

    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;

        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;

                return true;
            }

            return false;
        });

        return result;
    }

    return (function () {
        function anonymous() {
            this.__entries__ = [];
        }

        var prototypeAccessors = { size: { configurable: true } };

        /**
         * @returns {boolean}
         */
        prototypeAccessors.size.get = function () {
            return this.__entries__.length;
        };

        /**
         * @param {*} key
         * @returns {*}
         */
        anonymous.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];

            return entry && entry[1];
        };

        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        anonymous.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);

            if (~index) {
                this.__entries__[index][1] = value;
            } else {
                this.__entries__.push([key, value]);
            }
        };

        /**
         * @param {*} key
         * @returns {void}
         */
        anonymous.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);

            if (~index) {
                entries.splice(index, 1);
            }
        };

        /**
         * @param {*} key
         * @returns {void}
         */
        anonymous.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };

        /**
         * @returns {void}
         */
        anonymous.prototype.clear = function () {
            this.__entries__.splice(0);
        };

        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        anonymous.prototype.forEach = function (callback, ctx) {
            var this$1 = this;
            if ( ctx === void 0 ) ctx = null;

            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {
                var entry = list[i];

                callback.call(ctx, entry[1], entry[0]);
            }
        };

        Object.defineProperties( anonymous.prototype, prototypeAccessors );

        return anonymous;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }

    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }

    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }

    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }

    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;

/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
var throttle = function (callback, delay) {
    var leadingCall = false,
        trailingCall = false,
        lastCallTime = 0;

    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;

            callback();
        }

        if (trailingCall) {
            proxy();
        }
    }

    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }

    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();

        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }

            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        } else {
            leadingCall = true;
            trailingCall = false;

            setTimeout(timeoutCallback, delay);
        }

        lastCallTime = timeStamp;
    }

    return proxy;
};

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;

// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];

// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';

/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = function() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];

    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
};

/**
 * Adds observer to observers list.
 *
 * @param {ResizeObserverSPI} observer - Observer to be added.
 * @returns {void}
 */


/**
 * Holds reference to the controller's instance.
 *
 * @private {ResizeObserverController}
 */


/**
 * Keeps reference to the instance of MutationObserver.
 *
 * @private {MutationObserver}
 */

/**
 * Indicates whether DOM listeners have been added.
 *
 * @private {boolean}
 */
ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
    }

    // Add listeners if they haven't been added yet.
    if (!this.connected_) {
        this.connect_();
    }
};

/**
 * Removes observer from observers list.
 *
 * @param {ResizeObserverSPI} observer - Observer to be removed.
 * @returns {void}
 */
ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer);

    // Remove observer if it's present in registry.
    if (~index) {
        observers.splice(index, 1);
    }

    // Remove listeners if controller has no connected observers.
    if (!observers.length && this.connected_) {
        this.disconnect_();
    }
};

/**
 * Invokes the update of observers. It will continue running updates insofar
 * it detects changes.
 *
 * @returns {void}
 */
ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_();

    // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.
    if (changesDetected) {
        this.refresh();
    }
};

/**
 * Updates every observer from observers list and notifies them of queued
 * entries.
 *
 * @private
 * @returns {boolean} Returns "true" if any observer has detected changes in
 *  dimensions of it's elements.
 */
ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
    });

    // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.
    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });

    return activeObservers.length > 0;
};

/**
 * Initializes DOM listeners.
 *
 * @private
 * @returns {void}
 */
ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
        return;
    }

    // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.
    document.addEventListener('transitionend', this.onTransitionEnd_);

    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);

        this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
        });
    } else {
        document.addEventListener('DOMSubtreeModified', this.refresh);

        this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
};

/**
 * Removes DOM listeners.
 *
 * @private
 * @returns {void}
 */
ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
        return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
        document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
};

/**
 * "Transitionend" event handler.
 *
 * @private
 * @param {TransitionEvent} event
 * @returns {void}
 */
ResizeObserverController.prototype.onTransitionEnd_ = function (ref) {
        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';

    // Detect whether transition may affect dimensions of an element.
    var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
        this.refresh();
    }
};

/**
 * Returns instance of the ResizeObserverController.
 *
 * @returns {ResizeObserverController}
 */
ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
};

ResizeObserverController.instance_ = null;

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {
        var key = list[i];

        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }

    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;

    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);

/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}

/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [], len = arguments.length - 1;
    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];

    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];

        return size + toFloat(value);
    }, 0);
}

/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};

    for (var i = 0, list = positions; i < list.length; i += 1) {
        var position = list[i];

        var value = styles['padding-' + position];

        paddings[position] = toFloat(value);
    }

    return paddings;
}

/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();

    return createRectInit(0, 0, bbox.width, bbox.height);
}

/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth;
    var clientHeight = target.clientHeight;

    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }

    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;

    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width),
        height = toFloat(styles.height);

    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }

        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }

    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;

        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }

        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }

    return createRectInit(paddings.left, paddings.top, width, height);
}

/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }

    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };
})();

/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}

/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }

    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }

    return getHTMLElementContentRect(target);
}

/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(ref) {
    var x = ref.x;
    var y = ref.y;
    var width = ref.width;
    var height = ref.height;

    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);

    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });

    return rect;
}

/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = function(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);

    this.target = target;
};

/**
 * Updates content rectangle and tells whether it's width or height properties
 * have changed since the last broadcast.
 *
 * @returns {boolean}
 */


/**
 * Reference to the last observed content rectangle.
 *
 * @private {DOMRectInit}
 */


/**
 * Broadcasted width of content rectangle.
 *
 * @type {number}
 */
ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);

    this.contentRect_ = rect;

    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
};

/**
 * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
 * from the corresponding properties of the last observed content rectangle.
 *
 * @returns {DOMRectInit} Last observed content rectangle.
 */
ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;

    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;

    return rect;
};

var ResizeObserverEntry = function(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);

    // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.
    defineConfigurable(this, { target: target, contentRect: contentRect });
};

var ResizeObserverSPI = function(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
        throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
};

/**
 * Starts observing provided element.
 *
 * @param {Element} target - Element to be observed.
 * @returns {void}
 */


/**
 * Registry of the ResizeObservation instances.
 *
 * @private {Map<Element, ResizeObservation>}
 */


/**
 * Public ResizeObserver instance which will be passed to the callback
 * function and used as a value of it's "this" binding.
 *
 * @private {ResizeObserver}
 */

/**
 * Collection of resize observations that have detected changes in dimensions
 * of elements.
 *
 * @private {Array<ResizeObservation>}
 */
ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_;

    // Do nothing if element is already being observed.
    if (observations.has(target)) {
        return;
    }

    observations.set(target, new ResizeObservation(target));

    this.controller_.addObserver(this);

    // Force the update of observations.
    this.controller_.refresh();
};

/**
 * Stops observing provided element.
 *
 * @param {Element} target - Element to stop observing.
 * @returns {void}
 */
ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_;

    // Do nothing if element is not being observed.
    if (!observations.has(target)) {
        return;
    }

    observations.delete(target);

    if (!observations.size) {
        this.controller_.removeObserver(this);
    }
};

/**
 * Stops observing all elements.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
};

/**
 * Collects observation instances the associated element of which has changed
 * it's content rectangle.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.gatherActive = function () {
        var this$1 = this;

    this.clearActive();

    this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
            this$1.activeObservations_.push(observation);
        }
    });
};

/**
 * Invokes initial callback function with a list of ResizeObserverEntry
 * instances collected from active resize observations.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
        return;
    }

    var ctx = this.callbackCtx_;

    // Create ResizeObserverEntry instance for every active observation.
    var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });

    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
};

/**
 * Clears the collection of active observations.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
};

/**
 * Tells whether observer has active observations.
 *
 * @returns {boolean}
 */
ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
};

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();

/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = function(callback) {
    if (!(this instanceof ResizeObserver)) {
        throw new TypeError('Cannot call a class as a function.');
    }
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);

    observers.set(this, observer);
};

// Expose public methods of ResizeObserver.
['observe', 'unobserve', 'disconnect'].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        return (ref = observers.get(this))[method].apply(ref, arguments);
        var ref;
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }

    return ResizeObserver;
})();

return index;

})));

</script>

<script>

  /*!
 * fullscreen-polyfill
 * 1.0.2 - 5/23/2018
 * https://github.com/nguyenj/fullscreen-polyfill#readme
 * (c) John Nguyen; MIT License
 */
var FullscreenPolyfill=function(){"use strict";var l=["fullscreen","fullscreenEnabled","fullscreenElement","fullscreenchange","fullscreenerror","exitFullscreen","requestFullscreen"],e=["webkitIsFullScreen","webkitFullscreenEnabled","webkitFullscreenElement","webkitfullscreenchange","webkitfullscreenerror","webkitExitFullscreen","webkitRequestFullscreen"],n=["mozFullScreen","mozFullScreenEnabled","mozFullScreenElement","mozfullscreenchange","mozfullscreenerror","mozCancelFullScreen","mozRequestFullScreen"],u=["","msFullscreenEnabled","msFullscreenElement","MSFullscreenChange","MSFullscreenError","msExitFullscreen","msRequestFullscreen"];document||(document={});var t,c=(t=[l[1],e[1],n[1],u[1]].find(function(e){return document[e]}),[l,e,n,u].find(function(e){return e.find(function(e){return e===t})})||[]);function r(e,n){document[l[0]]=document[c[0]]||!!document[c[2]]||!1,document[l[1]]=document[c[1]]||!1,document[l[2]]=document[c[2]]||null,document.dispatchEvent(new Event(e),n.target)}return document[l[1]]?{}:(document[l[0]]=document[c[0]]||!!document[c[2]]||!1,document[l[1]]=document[c[1]]||!1,document[l[2]]=document[c[2]]||null,document.addEventListener(c[3],r.bind(document,l[3]),!1),document.addEventListener(c[4],r.bind(document,l[4]),!1),document[l[5]]=function(){return document[c[5]]()},void(Element.prototype[l[6]]=function(){return this[c[6]].apply(this,arguments)}))}();
//# sourceMappingURL=fullscreen.polyfill.js.map

</script>



<script>
  /**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

(function(window, document) {
'use strict';


// Exits early if all IntersectionObserver and IntersectionObserverEntry
// features are natively supported.
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

  // Minimal polyfill for Edge 15's lack of `isIntersecting`
  // See: https://github.com/w3c/IntersectionObserver/issues/211
  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
    Object.defineProperty(window.IntersectionObserverEntry.prototype,
      'isIntersecting', {
      get: function () {
        return this.intersectionRatio > 0;
      }
    });
  }
  return;
}


/**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observing a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
var registry = [];


/**
 * Creates the global IntersectionObserverEntry constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */
function IntersectionObserverEntry(entry) {
  this.time = entry.time;
  this.target = entry.target;
  this.rootBounds = entry.rootBounds;
  this.boundingClientRect = entry.boundingClientRect;
  this.intersectionRect = entry.intersectionRect || getEmptyRect();
  this.isIntersecting = !!entry.intersectionRect;

  // Calculates the intersection ratio.
  var targetRect = this.boundingClientRect;
  var targetArea = targetRect.width * targetRect.height;
  var intersectionRect = this.intersectionRect;
  var intersectionArea = intersectionRect.width * intersectionRect.height;

  // Sets intersection ratio.
  if (targetArea) {
    // Round the intersection ratio to avoid floating point math issues:
    // https://github.com/w3c/IntersectionObserver/issues/324
    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
  } else {
    // If area is zero and is intersecting, sets to 1, otherwise to 0
    this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
}


/**
 * Creates the global IntersectionObserver constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */
function IntersectionObserver(callback, opt_options) {

  var options = opt_options || {};

  if (typeof callback != 'function') {
    throw new Error('callback must be a function');
  }

  if (options.root && options.root.nodeType != 1) {
    throw new Error('root must be an Element');
  }

  // Binds and throttles `this._checkForIntersections`.
  this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

  // Private properties.
  this._callback = callback;
  this._observationTargets = [];
  this._queuedEntries = [];
  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

  // Public properties.
  this.thresholds = this._initThresholds(options.threshold);
  this.root = options.root || null;
  this.rootMargin = this._rootMarginValues.map(function(margin) {
    return margin.value + margin.unit;
  }).join(' ');
}


/**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


/**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
IntersectionObserver.prototype.POLL_INTERVAL = null;

/**
 * Use a mutation observer on the root element
 * to detect intersection changes.
 */
IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


/**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.observe = function(target) {
  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
    return item.element == target;
  });

  if (isTargetAlreadyObserved) {
    return;
  }

  if (!(target && target.nodeType == 1)) {
    throw new Error('target must be an Element');
  }

  this._registerInstance();
  this._observationTargets.push({element: target, entry: null});
  this._monitorIntersections();
  this._checkForIntersections();
};


/**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.unobserve = function(target) {
  this._observationTargets =
      this._observationTargets.filter(function(item) {

    return item.element != target;
  });
  if (!this._observationTargets.length) {
    this._unmonitorIntersections();
    this._unregisterInstance();
  }
};


/**
 * Stops observing all target elements for intersection changes.
 */
IntersectionObserver.prototype.disconnect = function() {
  this._observationTargets = [];
  this._unmonitorIntersections();
  this._unregisterInstance();
};


/**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
IntersectionObserver.prototype.takeRecords = function() {
  var records = this._queuedEntries.slice();
  this._queuedEntries = [];
  return records;
};


/**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
  var threshold = opt_threshold || [0];
  if (!Array.isArray(threshold)) threshold = [threshold];

  return threshold.sort().filter(function(t, i, a) {
    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
      throw new Error('threshold must be a number between 0 and 1 inclusively');
    }
    return t !== a[i - 1];
  });
};


/**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
  var marginString = opt_rootMargin || '0px';
  var margins = marginString.split(/\s+/).map(function(margin) {
    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
    if (!parts) {
      throw new Error('rootMargin must be specified in pixels or percent');
    }
    return {value: parseFloat(parts[1]), unit: parts[2]};
  });

  // Handles shorthand.
  margins[1] = margins[1] || margins[0];
  margins[2] = margins[2] || margins[0];
  margins[3] = margins[3] || margins[1];

  return margins;
};


/**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibility state is visible.
 * @private
 */
IntersectionObserver.prototype._monitorIntersections = function() {
  if (!this._monitoringIntersections) {
    this._monitoringIntersections = true;

    // If a poll interval is set, use polling instead of listening to
    // resize and scroll events or DOM mutations.
    if (this.POLL_INTERVAL) {
      this._monitoringInterval = setInterval(
          this._checkForIntersections, this.POLL_INTERVAL);
    }
    else {
      addEvent(window, 'resize', this._checkForIntersections, true);
      addEvent(document, 'scroll', this._checkForIntersections, true);

      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
        this._domObserver = new MutationObserver(this._checkForIntersections);
        this._domObserver.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @private
 */
IntersectionObserver.prototype._unmonitorIntersections = function() {
  if (this._monitoringIntersections) {
    this._monitoringIntersections = false;

    clearInterval(this._monitoringInterval);
    this._monitoringInterval = null;

    removeEvent(window, 'resize', this._checkForIntersections, true);
    removeEvent(document, 'scroll', this._checkForIntersections, true);

    if (this._domObserver) {
      this._domObserver.disconnect();
      this._domObserver = null;
    }
  }
};


/**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
IntersectionObserver.prototype._checkForIntersections = function() {
  var rootIsInDom = this._rootIsInDom();
  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

  this._observationTargets.forEach(function(item) {
    var target = item.element;
    var targetRect = getBoundingClientRect(target);
    var rootContainsTarget = this._rootContainsTarget(target);
    var oldEntry = item.entry;
    var intersectionRect = rootIsInDom && rootContainsTarget &&
        this._computeTargetAndRootIntersection(target, rootRect);

    var newEntry = item.entry = new IntersectionObserverEntry({
      time: now(),
      target: target,
      boundingClientRect: targetRect,
      rootBounds: rootRect,
      intersectionRect: intersectionRect
    });

    if (!oldEntry) {
      this._queuedEntries.push(newEntry);
    } else if (rootIsInDom && rootContainsTarget) {
      // If the new entry intersection ratio has crossed any of the
      // thresholds, add a new entry.
      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
        this._queuedEntries.push(newEntry);
      }
    } else {
      // If the root is not in the DOM or target is not contained within
      // root but the previous entry for this target had an intersection,
      // add a new record indicating removal.
      if (oldEntry && oldEntry.isIntersecting) {
        this._queuedEntries.push(newEntry);
      }
    }
  }, this);

  if (this._queuedEntries.length) {
    this._callback(this.takeRecords(), this);
  }
};


/**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
IntersectionObserver.prototype._computeTargetAndRootIntersection =
    function(target, rootRect) {

  // If the element isn't displayed, an intersection can't happen.
  if (window.getComputedStyle(target).display == 'none') return;

  var targetRect = getBoundingClientRect(target);
  var intersectionRect = targetRect;
  var parent = getParentNode(target);
  var atRoot = false;

  while (!atRoot) {
    var parentRect = null;
    var parentComputedStyle = parent.nodeType == 1 ?
        window.getComputedStyle(parent) : {};

    // If the parent isn't displayed, an intersection can't happen.
    if (parentComputedStyle.display == 'none') return;

    if (parent == this.root || parent == document) {
      atRoot = true;
      parentRect = rootRect;
    } else {
      // If the element has a non-visible overflow, and it's not the <body>
      // or <html> element, update the intersection rect.
      // Note: <body> and <html> cannot be clipped to a rect that's not also
      // the document rect, so no need to compute a new intersection.
      if (parent != document.body &&
          parent != document.documentElement &&
          parentComputedStyle.overflow != 'visible') {
        parentRect = getBoundingClientRect(parent);
      }
    }

    // If either of the above conditionals set a new parentRect,
    // calculate new intersection data.
    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

      if (!intersectionRect) break;
    }
    parent = getParentNode(parent);
  }
  return intersectionRect;
};


/**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {Object} The expanded root rect.
 * @private
 */
IntersectionObserver.prototype._getRootRect = function() {
  var rootRect;
  if (this.root) {
    rootRect = getBoundingClientRect(this.root);
  } else {
    // Use <html>/<body> instead of window since scroll bars affect size.
    var html = document.documentElement;
    var body = document.body;
    rootRect = {
      top: 0,
      left: 0,
      right: html.clientWidth || body.clientWidth,
      width: html.clientWidth || body.clientWidth,
      bottom: html.clientHeight || body.clientHeight,
      height: html.clientHeight || body.clientHeight
    };
  }
  return this._expandRectByRootMargin(rootRect);
};


/**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {Object} rect The rect object to expand.
 * @return {Object} The expanded rect.
 * @private
 */
IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
  var margins = this._rootMarginValues.map(function(margin, i) {
    return margin.unit == 'px' ? margin.value :
        margin.value * (i % 2 ? rect.width : rect.height) / 100;
  });
  var newRect = {
    top: rect.top - margins[0],
    right: rect.right + margins[1],
    bottom: rect.bottom + margins[2],
    left: rect.left - margins[3]
  };
  newRect.width = newRect.right - newRect.left;
  newRect.height = newRect.bottom - newRect.top;

  return newRect;
};


/**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
IntersectionObserver.prototype._hasCrossedThreshold =
    function(oldEntry, newEntry) {

  // To make comparing easier, an entry that has a ratio of 0
  // but does not actually intersect is given a value of -1
  var oldRatio = oldEntry && oldEntry.isIntersecting ?
      oldEntry.intersectionRatio || 0 : -1;
  var newRatio = newEntry.isIntersecting ?
      newEntry.intersectionRatio || 0 : -1;

  // Ignore unchanged ratios
  if (oldRatio === newRatio) return;

  for (var i = 0; i < this.thresholds.length; i++) {
    var threshold = this.thresholds[i];

    // Return true if an entry matches a threshold or if the new ratio
    // and the old ratio are on the opposite sides of a threshold.
    if (threshold == oldRatio || threshold == newRatio ||
        threshold < oldRatio !== threshold < newRatio) {
      return true;
    }
  }
};


/**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
IntersectionObserver.prototype._rootIsInDom = function() {
  return !this.root || containsDeep(document, this.root);
};


/**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
IntersectionObserver.prototype._rootContainsTarget = function(target) {
  return containsDeep(this.root || document, target);
};


/**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
IntersectionObserver.prototype._registerInstance = function() {
  if (registry.indexOf(this) < 0) {
    registry.push(this);
  }
};


/**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
IntersectionObserver.prototype._unregisterInstance = function() {
  var index = registry.indexOf(this);
  if (index != -1) registry.splice(index, 1);
};


/**
 * Returns the result of the performance.now() method or null in browsers
 * that don't support the API.
 * @return {number} The elapsed time since the page was requested.
 */
function now() {
  return window.performance && performance.now && performance.now();
}


/**
 * Throttles a function and delays its execution, so it's only called at most
 * once within a given time period.
 * @param {Function} fn The function to throttle.
 * @param {number} timeout The amount of time that must pass before the
 *     function can be called again.
 * @return {Function} The throttled function.
 */
function throttle(fn, timeout) {
  var timer = null;
  return function () {
    if (!timer) {
      timer = setTimeout(function() {
        fn();
        timer = null;
      }, timeout);
    }
  };
}


/**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
function addEvent(node, event, fn, opt_useCapture) {
  if (typeof node.addEventListener == 'function') {
    node.addEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.attachEvent == 'function') {
    node.attachEvent('on' + event, fn);
  }
}


/**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */
function removeEvent(node, event, fn, opt_useCapture) {
  if (typeof node.removeEventListener == 'function') {
    node.removeEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.detatchEvent == 'function') {
    node.detatchEvent('on' + event, fn);
  }
}


/**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object} The intersection rect or undefined if no intersection
 *     is found.
 */
function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;

  return (width >= 0 && height >= 0) && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  };
}


/**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {Object} The (possibly shimmed) rect of the element.
 */
function getBoundingClientRect(el) {
  var rect;

  try {
    rect = el.getBoundingClientRect();
  } catch (err) {
    // Ignore Windows 7 IE11 "Unspecified error"
    // https://github.com/w3c/IntersectionObserver/pull/205
  }

  if (!rect) return getEmptyRect();

  // Older IE
  if (!(rect.width && rect.height)) {
    rect = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  return rect;
}


/**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {Object} The empty rect.
 */
function getEmptyRect() {
  return {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0
  };
}

/**
 * Checks to see if a parent element contains a child element (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
function containsDeep(parent, child) {
  var node = child;
  while (node) {
    if (node == parent) return true;

    node = getParentNode(node);
  }
  return false;
}


/**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */
function getParentNode(node) {
  var parent = node.parentNode;

  if (parent && parent.nodeType == 11 && parent.host) {
    // If the parent is a shadow root, return the host element.
    return parent.host;
  }

  if (parent && parent.assignedSlot) {
    // If the parent is distributed in a <slot>, return the parent of a slot.
    return parent.assignedSlot.parentNode;
  }

  return parent;
}


// Exposes the constructors globally.
window.IntersectionObserver = IntersectionObserver;
window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));

</script>

<script>
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (factory());
}(this, (function () { 'use strict';

    const HAS_WEBXR_DEVICE_API = navigator.xr != null &&
        window.XRSession != null && window.XRDevice != null &&
        window.XRDevice.prototype.supportsSession != null;
    const HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API && window.XRSession.prototype.requestHitTest;
    const HAS_FULLSCREEN_API = document.documentElement != null &&
        document.documentElement.requestFullscreen != null;
    const IS_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API && HAS_FULLSCREEN_API;
    const IS_MOBILE = (() => {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        let check = false;
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
            .test(userAgent) ||
            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
                .test(userAgent.substr(0, 4))) {
            check = true;
        }
        return check;
    })();
    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // serializer/deserializers for boolean attribute
    const fromBooleanAttribute = (value) => value !== null;
    const toBooleanAttribute = (value) => value ? '' : null;
    /**
     * Change function that returns true if `value` is different from `oldValue`.
     * This method is used as the default for a property's `hasChanged` function.
     */
    const notEqual = (value, old) => {
        // This ensures (old==NaN, value==NaN) always returns false
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration = {
        attribute: true,
        type: String,
        reflect: false,
        hasChanged: notEqual
    };
    const microtaskPromise = new Promise((resolve) => resolve(true));
    const STATE_HAS_UPDATED = 1;
    const STATE_UPDATE_REQUESTED = 1 << 2;
    const STATE_IS_REFLECTING = 1 << 3;
    /**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     */
    class UpdatingElement extends HTMLElement {
        constructor() {
            super();
            this._updateState = 0;
            this._instanceProperties = undefined;
            this._updatePromise = microtaskPromise;
            /**
             * Map with keys for any properties that have changed since the last
             * update cycle with previous values.
             */
            this._changedProperties = new Map();
            /**
             * Map with keys of properties that should be reflected when updated.
             */
            this._reflectingProperties = undefined;
            this.initialize();
        }
        /**
         * Returns a list of attributes corresponding to the registered properties.
         */
        static get observedAttributes() {
            // note: piggy backing on this to ensure we're _finalized.
            this._finalize();
            const attributes = [];
            for (const [p, v] of this._classProperties) {
                const attr = this._attributeNameForProperty(p, v);
                if (attr !== undefined) {
                    this._attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            }
            return attributes;
        }
        /**
         * Creates a property accessor on the element prototype if one does not exist.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         */
        static createProperty(name, options = defaultPropertyDeclaration) {
            // ensure private storage for property declarations.
            if (!this.hasOwnProperty('_classProperties')) {
                this._classProperties = new Map();
                // NOTE: Workaround IE11 not supporting Map constructor argument.
                const superProperties = Object.getPrototypeOf(this)._classProperties;
                if (superProperties !== undefined) {
                    superProperties.forEach((v, k) => this._classProperties.set(k, v));
                }
            }
            this._classProperties.set(name, options);
            // Allow user defined accessors by not replacing an existing own-property
            // accessor.
            if (this.prototype.hasOwnProperty(name)) {
                return;
            }
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            Object.defineProperty(this.prototype, name, {
                get() { return this[key]; },
                set(value) {
                    const oldValue = this[name];
                    this[key] = value;
                    this._requestPropertyUpdate(name, oldValue, options);
                },
                configurable: true,
                enumerable: true
            });
        }
        /**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         */
        static _finalize() {
            if (this.hasOwnProperty('_finalized') && this._finalized) {
                return;
            }
            // finalize any superclasses
            const superCtor = Object.getPrototypeOf(this);
            if (typeof superCtor._finalize === 'function') {
                superCtor._finalize();
            }
            this._finalized = true;
            // initialize Map populated in observedAttributes
            this._attributeToPropertyMap = new Map();
            // make any properties
            const props = this.properties;
            // support symbols in properties (IE11 does not support this)
            const propKeys = [
                ...Object.getOwnPropertyNames(props),
                ...(typeof Object.getOwnPropertySymbols === 'function')
                    ? Object.getOwnPropertySymbols(props)
                    : []
            ];
            for (const p of propKeys) {
                // note, use of `any` is due to TypeSript lack of support for symbol in
                // index types
                this.createProperty(p, props[p]);
            }
        }
        /**
         * Returns the property name for the given attribute `name`.
         */
        static _attributeNameForProperty(name, options) {
            const attribute = options !== undefined && options.attribute;
            return attribute === false
                ? undefined
                : (typeof attribute === 'string'
                    ? attribute
                    : (typeof name === 'string' ? name.toLowerCase()
                        : undefined));
        }
        /**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         */
        static _valueHasChanged(value, old, hasChanged = notEqual) {
            return hasChanged(value, old);
        }
        /**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's `type`
         * or `type.fromAttribute` property option.
         */
        static _propertyValueFromAttribute(value, options) {
            const type = options && options.type;
            if (type === undefined) {
                return value;
            }
            // Note: special case `Boolean` so users can use it as a `type`.
            const fromAttribute = type === Boolean
                ? fromBooleanAttribute
                : (typeof type === 'function' ? type : type.fromAttribute);
            return fromAttribute ? fromAttribute(value) : value;
        }
        /**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         */
        static _propertyValueToAttribute(value, options) {
            if (options === undefined || options.reflect === undefined) {
                return;
            }
            // Note: special case `Boolean` so users can use it as a `type`.
            const toAttribute = options.type === Boolean
                ? toBooleanAttribute
                : (options.type &&
                    options.type.toAttribute ||
                    String);
            return toAttribute(value);
        }
        /**
         * Performs element initialization. By default this calls `createRenderRoot`
         * to create the element `renderRoot` node and captures any pre-set values for
         * registered properties.
         */
        initialize() {
            this.renderRoot = this.createRenderRoot();
            this._saveInstanceProperties();
        }
        /**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */
        _saveInstanceProperties() {
            for (const [p] of this.constructor
                ._classProperties) {
                if (this.hasOwnProperty(p)) {
                    const value = this[p];
                    delete this[p];
                    if (!this._instanceProperties) {
                        this._instanceProperties = new Map();
                    }
                    this._instanceProperties.set(p, value);
                }
            }
        }
        /**
         * Applies previously saved instance properties.
         */
        _applyInstanceProperties() {
            for (const [p, v] of this._instanceProperties) {
                this[p] = v;
            }
            this._instanceProperties = undefined;
        }
        /**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */
        createRenderRoot() {
            return this.attachShadow({ mode: 'open' });
        }
        /**
         * Uses ShadyCSS to keep element DOM updated.
         */
        connectedCallback() {
            if ((this._updateState & STATE_HAS_UPDATED)) {
                if (window.ShadyCSS !== undefined) {
                    window.ShadyCSS.styleElement(this);
                }
            }
            else {
                this.requestUpdate();
            }
        }
        /**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */
        disconnectedCallback() { }
        /**
         * Synchronizes property values when attributes change.
         */
        attributeChangedCallback(name, old, value) {
            if (old !== value) {
                this._attributeToProperty(name, value);
            }
        }
        _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
            const ctor = this.constructor;
            const attrValue = ctor._propertyValueToAttribute(value, options);
            if (attrValue !== undefined) {
                const attr = ctor._attributeNameForProperty(name, options);
                if (attr !== undefined) {
                    // Track if the property is being reflected to avoid
                    // setting the property again via `attributeChangedCallback`. Note:
                    // 1. this takes advantage of the fact that the callback is synchronous.
                    // 2. will behave incorrectly if multiple attributes are in the reaction
                    // stack at time of calling. However, since we process attributes
                    // in `update` this should not be possible (or an extreme corner case
                    // that we'd like to discover).
                    // mark state reflecting
                    this._updateState = this._updateState | STATE_IS_REFLECTING;
                    if (attrValue === null) {
                        this.removeAttribute(attr);
                    }
                    else {
                        this.setAttribute(attr, attrValue);
                    }
                    // mark state not reflecting
                    this._updateState = this._updateState & ~STATE_IS_REFLECTING;
                }
            }
        }
        _attributeToProperty(name, value) {
            // Use tracking info to avoid deserializing attribute value if it was
            // just set from a property setter.
            if (!(this._updateState & STATE_IS_REFLECTING)) {
                const ctor = this.constructor;
                const propName = ctor._attributeToPropertyMap.get(name);
                if (propName !== undefined) {
                    const options = ctor._classProperties.get(propName);
                    this[propName] =
                        ctor._propertyValueFromAttribute(value, options);
                }
            }
        }
        /**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */
        requestUpdate(name, oldValue) {
            if (name !== undefined) {
                const options = this.constructor
                    ._classProperties.get(name) ||
                    defaultPropertyDeclaration;
                return this._requestPropertyUpdate(name, oldValue, options);
            }
            return this._invalidate();
        }
        /**
         * Requests an update for a specific property and records change information.
         * @param name {PropertyKey} name of requesting property
         * @param oldValue {any} old value of requesting property
         * @param options {PropertyDeclaration}
         */
        _requestPropertyUpdate(name, oldValue, options) {
            if (!this.constructor
                ._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                return this.updateComplete;
            }
            // track old value when changing.
            if (!this._changedProperties.has(name)) {
                this._changedProperties.set(name, oldValue);
            }
            // add to reflecting properties set
            if (options.reflect === true) {
                if (this._reflectingProperties === undefined) {
                    this._reflectingProperties = new Map();
                }
                this._reflectingProperties.set(name, options);
            }
            return this._invalidate();
        }
        /**
         * Invalidates the element causing it to asynchronously update regardless
         * of whether or not any property changes are pending. This method is
         * automatically called when any registered property changes.
         */
        async _invalidate() {
            if (!this._hasRequestedUpdate) {
                // mark state updating...
                this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
                let resolver;
                const previousValidatePromise = this._updatePromise;
                this._updatePromise = new Promise((r) => resolver = r);
                await previousValidatePromise;
                this._validate();
                resolver(!this._hasRequestedUpdate);
            }
            return this.updateComplete;
        }
        get _hasRequestedUpdate() {
            return (this._updateState & STATE_UPDATE_REQUESTED);
        }
        /**
         * Validates the element by updating it.
         */
        _validate() {
            // Mixin instance properties once, if they exist.
            if (this._instanceProperties) {
                this._applyInstanceProperties();
            }
            if (this.shouldUpdate(this._changedProperties)) {
                const changedProperties = this._changedProperties;
                this.update(changedProperties);
                this._markUpdated();
                if (!(this._updateState & STATE_HAS_UPDATED)) {
                    this._updateState = this._updateState | STATE_HAS_UPDATED;
                    this.firstUpdated(changedProperties);
                }
                this.updated(changedProperties);
            }
            else {
                this._markUpdated();
            }
        }
        _markUpdated() {
            this._changedProperties = new Map();
            this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
        }
        /**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. This getter can be implemented to
         * await additional state. For example, it is sometimes useful to await a
         * rendered element before fulfilling this Promise. To do this, first await
         * `super.updateComplete` then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */
        get updateComplete() { return this._updatePromise; }
        /**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */
        shouldUpdate(_changedProperties) {
            return true;
        }
        /**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated DOM in the element's
         * `renderRoot`. Setting properties inside this method will *not* trigger
         * another update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */
        update(_changedProperties) {
            if (this._reflectingProperties !== undefined &&
                this._reflectingProperties.size > 0) {
                for (const [k, v] of this._reflectingProperties) {
                    this._propertyToAttribute(k, this[k], v);
                }
                this._reflectingProperties = undefined;
            }
        }
        /**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */
        updated(_changedProperties) { }
        /**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */
        firstUpdated(_changedProperties) { }
    }
    /**
     * Maps attribute names to properties; for example `foobar` attribute
     * to `fooBar` property.
     */
    UpdatingElement._attributeToPropertyMap = new Map();
    /**
     * Marks class as having finished creating properties.
     */
    UpdatingElement._finalized = true;
    /**
     * Memoized list of all class properties, including any superclass properties.
     */
    UpdatingElement._classProperties = new Map();
    UpdatingElement.properties = {};

  
          
          
          
</script>
